<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>HashMap源码阅读</title>
      <link href="/2020/03/14/HashMap%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
      <url>/2020/03/14/HashMap%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<p>HashMap作为Java中经典的工具类，基本是面试官必问的问题。本次源码分析基于java8,都是自己的学习笔记</p><a id="more"></a><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                               loadFactor);</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">        <span class="comment">//tableSizeFor返回的threshold是负载容量</span></span><br><span class="line">        <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields default</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">        putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>HashMap 一共四种构造方法的构造传入参数为初始容量initialCapacity 和负载因子loadFactor 默认分别为16和0.75</p><h4 id="tableSizeFor-方法"><a href="#tableSizeFor-方法" class="headerlink" title="tableSizeFor() 方法"></a>tableSizeFor() 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">       n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">       n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">       n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">       n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">       n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">       <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这个方法很有意思,不具体解释，主要是通过位移运算找到在cap值以上最小的2的次幂数。</p><h3 id="hash方法"><a href="#hash方法" class="headerlink" title="hash方法"></a>hash方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">        <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>主要是调用hashCode()方法与自己本身的无符号右移16位做的异或运算。</p><p>官方注释的大概意思是：<br>寻址计算时，能够参与到计算的有效二进制位仅仅是右侧和数组长度值对应的那几位，意味着发生碰撞的几率会高。<br>通过移位和异或运算让hashCode的高位能够参与到寻址计算中。<br>采用这种方式是为了在性能、实用性、分布质量上取得一个平衡。<br>有很多hashCode算法都已经是分布合理的了，并且大量碰撞时，还可以通过树结构来解决查询性能问题。<br>所以用了性能比较高的位运算来让高位参与到寻址运算中，位运算对于系统损耗相对低廉。</p><p>总结就是通过对产生的hash值增加一个高位扰动，来减少碰撞几率，也就是<strong>扰动因子</strong>。可以一定程度上减少hash值取模后的碰撞，但并不能杜绝,1.8之前是用了四次扰动的办法，估计觉得性能影响，改成了一次扰动。</p><h3 id="putVal-方法"><a href="#putVal-方法" class="headerlink" title="putVal()方法"></a>putVal()方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Implements Map.put and related methods</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> value the value to put</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> onlyIfAbsent if true, don't change existing value</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> evict if false, the table is in creation mode.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> previous value, or null if none</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">       Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">       <span class="comment">//如果存储元素的数组table为空，则初始化变量</span></span><br><span class="line">       <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">           n = (tab = resize()).length;</span><br><span class="line">       <span class="comment">//如果根据hash值取模获取的下表节点为空，则新建节点并赋值给该下标位置节点</span></span><br><span class="line">       <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">           tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">           <span class="comment">//p为对应数组中的元素</span></span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">           Node&lt;K,V&gt; e; K k;</span><br><span class="line">           <span class="comment">//如果插入的节点hash值和p的hash值相同且key值相同</span></span><br><span class="line">           <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">               ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">               e = p;</span><br><span class="line">           <span class="comment">//如果是p是TreeNode（红黑树），则进行红黑树插入</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">               e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                   <span class="comment">//该链上只有一个头部节点</span></span><br><span class="line">                   <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                       p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                       <span class="comment">//当节点数大于默认的长度，即8的时候，将该链转为红黑树</span></span><br><span class="line">                       <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                           treeifyBin(tab, hash);</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                       ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   <span class="comment">//跟新p值</span></span><br><span class="line">                   p = e;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//如果存在这个映射就覆盖</span></span><br><span class="line">           <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">               V oldValue = e.value;</span><br><span class="line">               <span class="comment">//onlyIfAbsenet(不允许覆盖)</span></span><br><span class="line">               <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                   e.value = value;</span><br><span class="line">               <span class="comment">//LinkHashMap的后置处理，主要是将节点放在链尾</span></span><br><span class="line">               afterNodeAccess(e);</span><br><span class="line">               <span class="keyword">return</span> oldValue;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       ++modCount;</span><br><span class="line">       <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">       <span class="comment">//当前容量大于负载量的时候，进行扩容</span></span><br><span class="line">           resize();</span><br><span class="line">       <span class="comment">//LinkHashMap的后置处理</span></span><br><span class="line">       afterNodeInsertion(evict);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> Java源码 </category>
          
          <category> HashMap </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HashMap </tag>
            
            <tag> Java </tag>
            
            <tag> Java源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过源码认识spring中的循环依赖</title>
      <link href="/2020/03/10/%E9%80%9A%E8%BF%87%E6%BA%90%E7%A0%81%E8%AE%A4%E8%AF%86spring%E4%B8%AD%E7%9A%84%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/"/>
      <url>/2020/03/10/%E9%80%9A%E8%BF%87%E6%BA%90%E7%A0%81%E8%AE%A4%E8%AF%86spring%E4%B8%AD%E7%9A%84%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>微服务入门</title>
      <link href="/2020/03/03/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8/"/>
      <url>/2020/03/03/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>微服务是目前的互联网公司的主要架构方式，springCloud是目前互联网企业的主流框架，系统学习springCloud之前，先来学习下微服的内容。</p><a id="more"></a><h2 id="微服务是什么？"><a href="#微服务是什么？" class="headerlink" title="微服务是什么？"></a>微服务是什么？</h2><p>原文： <a href="https://www.martinfowler.com/articles/microservices.html" target="_blank" rel="noopener">https://www.martinfowler.com/articles/microservices.html</a></p><p>汉化：<a href="https://www.cnblogs.com/liuning8023/p/4493156.html" target="_blank" rel="noopener">https://www.cnblogs.com/liuning8023/p/4493156.html</a></p><ul><li>就目前而言，对于微服务，业界没有一个统一的，标准的定义</li><li>但通常而言，微服务架构是一种架构模式，或者说是一种架构风格，<strong>他提倡将单一的应用程序划分为一组小的服务</strong>，每个服运行在其独立的自己的进程内，服务之间相互协调，互相配置，为用户提供最终价值。服务之间采用轻量级的通信机制互相沟通，每个服务都围绕着具体的业务进行构建，并且能够被独立的部署到生产环境中，另外，应尽量避免统一的，集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言，工具对其进行构建，可以有一个非常轻量级的集中式管理来协调这些服务，可以使用不同的语言来编写服务，也可以使用不同的数据存储;</li></ul><p>一篇博客有详细的微服的说明,解释了微服务的应用场景</p><blockquote><p><a href="https://www.cnblogs.com/skabyy/p/11396571.html" target="_blank" rel="noopener">https://www.cnblogs.com/skabyy/p/11396571.html</a></p></blockquote><h2 id="微服务于微服务架构"><a href="#微服务于微服务架构" class="headerlink" title="微服务于微服务架构"></a>微服务于微服务架构</h2><h3 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h3><p>强调的是服务的大小。他关注的是某一个点，是具体解决某一个问题、提供落地对应服务的一个服务应用，狭义的看，可以看作是IDEA中的一个个微服务工程，或者Module</p><h3 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h3><p>一种新的架构形式，Martin Fowler,2014提出</p><p>微服务架构是一种架构模式，他提倡将单一应用程序划分成一组小的服务，服务之间相互协调，互相配合，为用户提供最终价值。每个服务运行在其独立的进程中，服务与服务之间采用轻量级的通信机制互相协作，每个服务都围绕着具体的业务进行构建，并且能够被独立的部署到生产环境中，另外，应尽量避免统一的，集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言，工具对其进行构建。</p><h2 id="微服务的优缺点"><a href="#微服务的优缺点" class="headerlink" title="微服务的优缺点"></a>微服务的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>单一职责原则</li><li>每个服务足够内聚，足够小，代码容易理解，这样能聚焦一个指定的业务功能或业务需求；</li><li>开发简单，开发效率高，一个服务可能就是专一的只干一件事；</li><li>微服务能够被小团队单独开发，这个小团队是2-5人的开发人员组成；</li><li>微服务是松耦合的，是有功能意义的服务，无论是在开发阶段或部署阶段都是独立的；</li><li>微服务能使用不同的语言开发；</li><li>易于和第三方集成，微服务允许容易且灵活的方式自动集成部署，通过持续集成工具，如Jenkins，Hudson，bamboo</li><li>微服务易于被一个开发人员理解，修改和维护，这样的小团队能够更关注自己的工作成果。无需通过合作才能体现价值</li><li>微服务允许你利用融合最新技术</li><li>微服务只是业务逻辑的代码，不会和HTML,CSS或其他界面混合</li><li>每个微服务都有自己的存储能力，可以有自己的数据库，也可以有统一的数据库</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>开发人员要处理分布式系统的复杂性</li><li>多服务运维难度，随着服务的增加，运维的压力也在增大</li><li>系统部署依赖</li><li>服务间通信成本</li><li>数据一致性</li><li>系统集成测试</li><li>性能监控…</li></ul><h2 id="微服务的而技术栈"><a href="#微服务的而技术栈" class="headerlink" title="微服务的而技术栈"></a>微服务的而技术栈</h2><table><thead><tr><th><strong>微服务条目</strong></th><th><strong>落地技术</strong></th></tr></thead><tbody><tr><td>服务开发</td><td>SpringBoot,Spring,SpringMVC</td></tr><tr><td>服务配置与管理</td><td>Netfix公司的Archaius、阿里的Dimond等</td></tr><tr><td>服务注册与发现</td><td>Eureka、Consul、Zookeeper等</td></tr><tr><td>服务调用</td><td>Rest、RPC、gRPC</td></tr><tr><td>服务熔断器</td><td>Hystrix、Envoy等</td></tr><tr><td>负载均衡</td><td>Ribbon、Nginx</td></tr><tr><td>服务接口调用（客户端调用服务端的简化工具）</td><td>Feign等</td></tr><tr><td>消息队列</td><td>Kafka、RabbitMQ、ActiveMQ等</td></tr><tr><td>服务配置中心管理</td><td>SpringCloudConfig、Chef等</td></tr><tr><td>服务路由（API网关）</td><td>Zuul等</td></tr><tr><td>服务监控</td><td>Zabbix、Nagious、Metrics、Specatator等</td></tr><tr><td>全链路追踪</td><td>Zipkin、Brave、Dapper等</td></tr><tr><td>服务部署</td><td>Docker、OpenStack、Kubernetes等</td></tr><tr><td>数据流操作开发包</td><td>SpringCloud Stream(封装与redis、Rabbit、Kafka等发送接收消息)</td></tr><tr><td>事件消息总线</td><td>SpringCloud Bus</td></tr></tbody></table><h2 id="为什么选择SpringCloud作为微服务架构"><a href="#为什么选择SpringCloud作为微服务架构" class="headerlink" title="为什么选择SpringCloud作为微服务架构"></a>为什么选择SpringCloud作为微服务架构</h2><h3 id="1、选型依据"><a href="#1、选型依据" class="headerlink" title="1、选型依据"></a>1、选型依据</h3><ul><li>整体解决方案和框架成熟度</li><li>社区热度</li><li>可维护性</li><li>学习曲线</li></ul><h3 id="2、当前各大IT公司用的微服务架构有哪些"><a href="#2、当前各大IT公司用的微服务架构有哪些" class="headerlink" title="2、当前各大IT公司用的微服务架构有哪些"></a>2、当前各大IT公司用的微服务架构有哪些</h3><ul><li>阿里：dubbo+HFS</li><li>京东：JSF</li><li>新浪: Motan</li><li>当当网：DubboX</li><li>…</li></ul><h3 id="3、各微服务框架对比"><a href="#3、各微服务框架对比" class="headerlink" title="3、各微服务框架对比"></a>3、各微服务框架对比</h3><table><thead><tr><th>功能点/服务框架</th><th>Netflix/SpringCloud</th><th>Motan</th><th>gRPC</th><th>Thrift</th><th>Dubbo</th><th>dubboX</th></tr></thead><tbody><tr><td>功能定位</td><td>完整的微服务框架</td><td>RPC框架，但整合了ZK或Consul，实现集群环境的基本服务注册/发现</td><td>RPC框架</td><td>RPC框架</td><td>服务框架</td><td></td></tr><tr><td>支持Rest</td><td>是，Ribbon支持多种可插拔的序列化选择</td><td>否</td><td>否</td><td>否</td><td>否</td><td></td></tr><tr><td>支持RPC</td><td>否</td><td>是（Hession2）</td><td>是</td><td>是</td><td>是</td><td></td></tr><tr><td>支持多语言</td><td>是（Rest形式）</td><td>否</td><td>是</td><td>是</td><td>否</td><td></td></tr><tr><td>负载均衡</td><td>是（服务端zuul+客户端Ribbon）,zuul-服务，动态路由，云端负载均衡Eureka(针对中间层服务器)</td><td>是（客户端）</td><td>否</td><td>否</td><td>是（客户端）</td><td></td></tr><tr><td>配置服务</td><td>Netflix Archaius,Spring Cloud config Server集中配置</td><td>是（zookeeper提供）</td><td>否</td><td>否</td><td>否</td><td></td></tr><tr><td>服务调用链监控</td><td>是（zuul）,zuul提供边缘服务，API网关</td><td>否</td><td>否</td><td>否</td><td></td><td></td></tr><tr><td>高可用/容错</td><td>是（服务端Hystrix+客户端Ribbon）</td><td>是</td><td>否</td><td>否</td><td>是（客户端）</td><td></td></tr><tr><td>典型应用案例</td><td>Netflix</td><td>Sina</td><td>Google</td><td>Facebook</td><td></td><td></td></tr><tr><td>社区活跃程度</td><td>高</td><td>一般</td><td>高</td><td>一般</td><td>2017年后重新开始维护，之前中断了5年</td><td></td></tr><tr><td>学习难度</td><td>中</td><td>低</td><td>高</td><td>高</td><td>低</td><td></td></tr><tr><td>文档丰富程度</td><td>高</td><td>一般</td><td>一般</td><td>一般</td><td>高</td><td></td></tr><tr><td>其他</td><td>Spring Cloud Bus为我们的应用程序带来更多管理端点</td><td>支持降级</td><td>Netflix内部在开发集成gRPC</td><td>IDL定义</td><td>实践的公司比较多</td><td></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> spring-cloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring-cloud </tag>
            
            <tag> 实战 </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日leetCode之两数之和</title>
      <link href="/2019/12/14/%E6%AF%8F%E6%97%A5leetCode%E4%B9%8B%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
      <url>/2019/12/14/%E6%AF%8F%E6%97%A5leetCode%E4%B9%8B%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<p>对于一个想要提升自身编程水平的程序员来说，leetCode是一个非常重要的题库。涉及的算法题不仅能让你应付面试中必考的算法题，也对自己代码的质量和算法优缺点有比较明显<br>的了解。</p><p>所以现在会定期刷算法题，当然估计不会像学生党天天刷。作为一个半路出家的java工程师，会保证定期定量的刷，习惯和坚持才是最好的老师。</p><p>目前主要用的是leetCode的vsCode插件，非常好用，节点用的是国内的，可以测试提交查看结果，关联自己的leetCode非常方便。</p><p>我会优先记录自己思考这道题的思路，有必要会看官网其他的思路，一起进步。</p><a id="more"></a><h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h2><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [2, 7, 11, 15], target = 9</span><br><span class="line"></span><br><span class="line">因为 nums[0] + nums[1] = 2 + 7 = 9</span><br><span class="line">所以返回 [0, 1]</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="1、暴力遍历法"><a href="#1、暴力遍历法" class="headerlink" title="1、暴力遍历法"></a>1、暴力遍历法</h3><p>两数相加结果为定值<br>第一反应必然就是遍历相加，筛选满足条件的target返回，我确实也是这么做的，代码非常简单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] twoSum(int[] nums, int target) &#123;</span><br><span class="line">        int[] twoSum=new int[2];</span><br><span class="line">        for(int i=0;i&lt;nums.length-1;i++)&#123;</span><br><span class="line">            for(int j=i+1;j&lt;nums.length;j++)&#123;</span><br><span class="line">                int sum=nums[i]+nums[j];</span><br><span class="line">                if(sum==target)&#123;</span><br><span class="line">                    twoSum[0]=i;</span><br><span class="line">                    twoSum[1]=j;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return twoSum;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提交leetCode结果返回如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Accepted</span><br><span class="line">29/29 cases passed (59 ms)</span><br><span class="line"></span><br><span class="line">Your runtime beats 10.57 % of java submissions</span><br><span class="line"></span><br><span class="line">Your memory usage beats 67.17 % of java submissions (38.4 MB)</span><br></pre></td></tr></table></figure><h4 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h4><p>时间复杂度：$O(n^2)$<br>对于每个元素，我们试图通过遍历数组的其余部分来寻找它所对应的目标元素，这将耗费 $O(n)O(n)$ 的时间。因此时间复杂度为 $O(n^2)$。</p><p>空间复杂度：$O(1)$。</p><p>虽然代码正确，但速度却用了59ms，所以我们需要思考其他的思路。</p><h3 id="2、构造HashMap查询法"><a href="#2、构造HashMap查询法" class="headerlink" title="2、构造HashMap查询法"></a>2、构造HashMap查询法</h3><p>暴力法的时间复杂度$O(n^2)$，我们期望构造$O(n)$复杂度的解决方案，在java中正好有这么一种数据结构满足要求，那就是hashmap。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] twoSum(int[] nums, int target) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">            int complement = target - nums[i];</span><br><span class="line">            if (map.containsKey(complement)) &#123;</span><br><span class="line">                return new int[] &#123; map.get(complement), i &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        throw new IllegalArgumentException(&quot;No two sum solution&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提交leetCode结果返回如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">29/29 cases passed (3 ms)</span><br><span class="line">Your runtime beats 98.08 % of java submissions</span><br><span class="line">Your memory usage beats 92.44 % of java submissions (37 MB)</span><br></pre></td></tr></table></figure><h4 id="复杂度分析：-1"><a href="#复杂度分析：-1" class="headerlink" title="复杂度分析："></a>复杂度分析：</h4><p>时间复杂度：$O(n)$，<br>我们把包含有 $n$ 个元素的列表遍历两次。由于哈希表将查找时间缩短到 $O(1)$ ，所以时间复杂度为 $O(n)$。</p><p>空间复杂度：$O(n)$，<br>所需的额外空间取决于哈希表中存储的元素数量，该表中存储了 $n$ 个元素。</p><p>这样的结果无疑是快速的，官方题解作为过渡，将两遍hash 和一遍hash做了区分，这里不做赘述。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> leetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetCode </tag>
            
            <tag> 两数之和 </tag>
            
            <tag> twoSum </tag>
            
            <tag> easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法记录</title>
      <link href="/2019/11/21/Markdown%E8%AF%AD%E6%B3%95%E8%AE%B0%E5%BD%95/"/>
      <url>/2019/11/21/Markdown%E8%AF%AD%E6%B3%95%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>虽然以前使用github接触过markdown语法，但是由于搭建博客以及后续博文撰写的关系，对markdown语法有了真正运用的场景。  </p><p>在这篇文章下逐渐更新对markdown的使用和理解！！！</p><a id="more"></a><h3 id="此文档在更新时可能会被覆盖或删除"><a href="#此文档在更新时可能会被覆盖或删除" class="headerlink" title="此文档在更新时可能会被覆盖或删除"></a>此文档在更新时可能会被覆盖或删除</h3><blockquote><p>在使用Markdown之前，你可能需要先了解一下关于markdown的简单语法。</p></blockquote><h3 id="1-标题"><a href="#1-标题" class="headerlink" title="1.标题"></a>1.标题</h3><ul><li>使用 <code>#</code> 表示标题，一级标题使用一个 <code>#</code> ，二级标题使用两个 <code>##</code> ，以此类推，共有六级标题。</li><li>使用 <code>=====</code> 表示高阶标题，使用 <code>---------</code> 表示次阶标题。</li></ul><ol><li><code>#</code> 和标题之间记得有个空格哦。</li><li><code>====</code> 和 <code>----</code> 表示标题时，大于等于2个都可以表示。</li></ol><h3 id="2-引用"><a href="#2-引用" class="headerlink" title="2.引用"></a>2.引用</h3><p>使用 <code>&gt;</code> 表示引用， <code>&gt;&gt;</code> 表示引用里面再套一层引用，依次类推。</p><ol><li>如果 <code>&gt;</code> 和 <code>&gt;&gt;</code> 嵌套使用的话，从 <code>&gt;&gt;</code> 退到 <code>&gt;</code> 时，必须之间要加一个空格或者 <code>&gt;</code> 作为过渡，否则默认为下一行和上一行是同一级别的引用。如示例所示。</li><li>引用标记里可以使用其他标记，如：有序列表或无序列表标记，代码标记等。</li></ol><p>示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; 这是一级引用</span><br><span class="line">&gt;&gt;这是二级引用</span><br><span class="line">&gt;&gt;&gt; 这是三级引用</span><br><span class="line"></span><br><span class="line">&gt;这是一级引用</span><br></pre></td></tr></table></figure><blockquote><p>这是一级引用</p><blockquote><p>这是二级引用</p><blockquote><p>这是三级引用</p></blockquote></blockquote></blockquote><blockquote><p>这是一级引用</p></blockquote><h3 id="3-代码块"><a href="#3-代码块" class="headerlink" title="3 代码块"></a>3 代码块</h3><p>使用3个连续的` 符号包围起来表示代码块。</p><ol><li>本文档所有使用讲解Markdown语法标记示例的地方都是使用代码块标记的。</li><li>代码块前后都得有换行哦</li></ol><p>示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(document).ready(function() &#123;</span><br><span class="line">  $(&apos;pre code&apos;).each(function(i, block) &#123;</span><br><span class="line">    hljs.highlightBlock(block);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="4-行内代码"><a href="#4-行内代码" class="headerlink" title="4 行内代码"></a>4 行内代码</h3><p>使用``表示行内代码。本页部分文字中间的英文字母就是使用行内代码标记标记的。</p><p>示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是 `javascript` 代码</span><br></pre></td></tr></table></figure><p>这是 <code>javascript</code> 代码</p><h4 id="5-链接"><a href="#5-链接" class="headerlink" title="5 链接"></a>5 链接</h4><p>使用 <code>[](link)</code> 表示行内链接。其中：</p><ul><li><code>[]</code> 内的内容为要添加链接的文字。</li><li><code>link</code> 为链接地址。</li></ul><p>示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我觉得[刘伟康](http://www.lwk4you.com)真是个帅帅的博主😊.</span><br></pre></td></tr></table></figure><p>我觉得<a href="http://www.lwk4you.com">刘伟康</a>真是个帅帅的博主😊.</p><h3 id="6-数学公式"><a href="#6-数学公式" class="headerlink" title="6 数学公式"></a>6 数学公式</h3><p><code>$</code>包围的区块将会解析为数学公式，连续的<code>$$</code>将独占一行并居中显示</p><p>示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当 $a \ne 0$, 此方程式有两个解 $ax^2 + bx + c = 0$，他们是 </span><br><span class="line"></span><br><span class="line">$$x = &#123;-b \pm \sqrt&#123;b^2-4ac&#125; \over 2a&#125;.$$</span><br></pre></td></tr></table></figure><p>当 $a \ne 0$, 此方程式有两个解 $ax^2 + bx + c = 0$，他们是 </p><p>$$x = {-b \pm \sqrt{b^2-4ac} \over 2a}.$$</p><h3 id="7-导入图片"><a href="#7-导入图片" class="headerlink" title="7 导入图片"></a>7 导入图片</h3><p>使用 <code>![Alt text](/path/to/img.jpg)</code> 导入图片。其中：</p><ul><li><code>Alt text</code> 为如果图片无法显示时显示的文字；</li><li><code>/path/to/img.jpg</code> 为图片所在路径；</li></ul><p>点击辅助键盘中的添加图片按钮可快捷添加图片</p><ol><li>==本地引用==是图片直接存储到本地通过相对路径引用，无需网络连接</li><li>==上传图片==将把图片上传至图床，这样在文档或图片移动时认可访问图片</li></ol><p>示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![Markdown](https://i.loli.net/2019/11/16/h4lWxQbjvUwN7XZ.jpg)</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/11/16/h4lWxQbjvUwN7XZ.jpg" alt="Markdown"></p><h3 id="8-Todo-List"><a href="#8-Todo-List" class="headerlink" title="8 Todo List"></a>8 Todo List</h3><p>小写x表示已完成， 空格表示未完成</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>[x] 支持数学公式</span><br><span class="line"><span class="bullet">- </span>[x] 支持TodoList</span><br><span class="line"><span class="bullet">- </span>[x] 支持自定义样式</span><br><span class="line"><span class="bullet">- </span>[ ] 支持自定义图床</span><br></pre></td></tr></table></figure><ul><li><input checked="" disabled="" type="checkbox"> 支持数学公式</li><li><input checked="" disabled="" type="checkbox"> 支持TodoList</li><li><input checked="" disabled="" type="checkbox"> 支持自定义样式</li><li><input disabled="" type="checkbox"> 支持自定义图床</li></ul><h3 id="9-粗体，斜体，高亮和删除线"><a href="#9-粗体，斜体，高亮和删除线" class="headerlink" title="9 粗体，斜体，高亮和删除线"></a>9 粗体，斜体，高亮和删除线</h3><ol><li>使用 <code>**</code> 或者 <code>__</code> 表示<strong>粗体</strong>。</li><li>使用 <code>*</code> 或者 <code>_</code> 表示<em>斜体</em>。</li><li>使用<code>~~</code>表示<del>删除</del></li><li><code>*</code>，<code>=</code> 或 <code>_</code> 的后面<strong>不要跟空格哦</strong></li></ol><h3 id="10-列表"><a href="#10-列表" class="headerlink" title="10 列表"></a>10 列表</h3><p>使用 <code>1. 2. 3.</code> 表示有序列表，使用 <code>*</code> 或 <code>-</code> 或 <code>+</code> 表示无序列表。</p><ol><li>无序列表或有序列表标记和后面的文字之间要有一个空格隔开。</li><li>有序列表标记不是按照你写的数字进行显示的，而是根据当前有序列表标记所在位置显示的，如示例1所示。</li><li>无序列表的项目符号是按照实心圆、空心圆、实心方格的层级关系递进的，如例2所示。通常情况下，同一层级使用同一种标记表示，便于自己查看和管理。</li></ol><h4 id="例1：有序列表"><a href="#例1：有序列表" class="headerlink" title="例1：有序列表"></a>例1：有序列表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.  第一点</span><br><span class="line">2.  第二点</span><br><span class="line">4.  第三点</span><br></pre></td></tr></table></figure><ol><li>第一点</li><li>第二点</li><li>第三点</li></ol><h4 id="例2：无序列表"><a href="#例2：无序列表" class="headerlink" title="例2：无序列表"></a>例2：无序列表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ 一级无序列表内容</span><br><span class="line">* 二级无序列表内容</span><br><span class="line">- 二级无序列表内容</span><br><span class="line">- 三级无序列表内容</span><br><span class="line">- 三级无序列表内容</span><br><span class="line">+ 一级无序列表内容</span><br><span class="line">- 二级无序列表内容</span><br></pre></td></tr></table></figure><ul><li>一级无序列表内容<ul><li>二级无序列表内容</li></ul><ul><li>二级无序列表内容<ul><li>三级无序列表内容</li><li>三级无序列表内容</li></ul></li></ul></li><li>一级无序列表内容<ul><li>二级无序列表内容</li></ul></li></ul><h3 id="11-分割线"><a href="#11-分割线" class="headerlink" title="11 分割线"></a>11 分割线</h3><p>使用 <code>---</code> 或者 <code>***</code> 或者 <code>* * *</code> 表示水平分割线。</p><ol><li>只要 <code>*</code> 或者 <code>-</code> 大于等于三个就可组成一条平行线。</li><li>使用 <code>---</code> 作为水平分割线时，要在它的前后都空一行，防止 <code>---</code> 被当成标题标记的表示方式。</li></ol><p>示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">***</span><br><span class="line"></span><br><span class="line">* * *</span><br></pre></td></tr></table></figure><hr><hr><hr><h3 id="12表格"><a href="#12表格" class="headerlink" title="12表格"></a>12表格</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">上面空一行下面空两行</span><br><span class="line"></span><br><span class="line">Heading | Heading | Heading</span><br><span class="line">------- | ------- | -------</span><br><span class="line">Cell   |  Cell   |  Cell</span><br><span class="line">Cell   |  Cell   |  Cell</span><br><span class="line"></span><br><span class="line">添加边框:</span><br><span class="line"></span><br><span class="line">| Heading | Heading | Heading |</span><br><span class="line">| ------- | ------- | ------- |</span><br><span class="line">|   Cell  |   Cell  |   Cell  |</span><br><span class="line">|   Cell  |   Cell  |   Cell  |</span><br><span class="line"></span><br><span class="line">对齐方式:</span><br><span class="line"></span><br><span class="line">Heading | Heading | Heading</span><br><span class="line">:----- | :----: | ------:</span><br><span class="line">Left   | Center | Right</span><br><span class="line">Left   | Center | Right</span><br></pre></td></tr></table></figure><p>上面空一行下面空两行</p><table><thead><tr><th>Heading</th><th>Heading</th><th>Heading</th></tr></thead><tbody><tr><td>Cell</td><td>Cell</td><td>Cell</td></tr><tr><td>Cell</td><td>Cell</td><td>Cell</td></tr></tbody></table><p>添加边框:</p><table><thead><tr><th>Heading</th><th>Heading</th><th>Heading</th></tr></thead><tbody><tr><td>Cell</td><td>Cell</td><td>Cell</td></tr><tr><td>Cell</td><td>Cell</td><td>Cell</td></tr></tbody></table><p>对齐方式:</p><table><thead><tr><th align="left">Heading</th><th align="center">Heading</th><th align="right">Heading</th></tr></thead><tbody><tr><td align="left">Left</td><td align="center">Center</td><td align="right">Right</td></tr><tr><td align="left">Left</td><td align="center">Center</td><td align="right">Right</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>两个小摆件</title>
      <link href="/2019/11/05/20191105/"/>
      <url>/2019/11/05/20191105/</url>
      
        <content type="html"><![CDATA[<h2 id="朋友从日本带的小玩意终于装好了"><a href="#朋友从日本带的小玩意终于装好了" class="headerlink" title="朋友从日本带的小玩意终于装好了"></a>朋友从日本带的小玩意终于装好了</h2><h3 id="拼装前"><a href="#拼装前" class="headerlink" title="拼装前"></a>拼装前</h3><img src="https://s2.ax1x.com/2019/11/05/M95Mc9.jpg" alt="M95Mc9.jpg"><h3 id="拼装后"><a href="#拼装后" class="headerlink" title="拼装后"></a>拼装后</h3><img src="https://s2.ax1x.com/2019/11/05/M95K1J.jpg" alt="M95K1J.jpg" ><p>明天带去办公室桌面吧，自己的桌子实在是太拥挤了呀！！</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活记录 </tag>
            
            <tag> 小物件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/10/28/hello-world/"/>
      <url>/2019/10/28/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
